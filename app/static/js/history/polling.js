// app/static/js/history/polling.js
// Title polling logic for autogenerated transcription titles.

(function initializeHistoryPolling(window) {
    const History = window.History;
    const { historyLogPrefix } = History.logger;
    const state = History.state;
    const idsToPollForTitle = state.idsToPollForTitle;
    const titlePollAttempts = state.titlePollAttempts;
    const { MAX_TITLE_POLL_ATTEMPTS, TITLE_POLL_INTERVAL_MS } = History.constants;

    /**
     * Fetches the title status for a single transcription ID.
     * @param {string} transcriptionId
     */
    async function fetchTitleStatus(transcriptionId) {
        const pollLogPrefix = `[HistoryJS:TitlePoll:${transcriptionId.substring(0, 8)}]`;
        try {
            const response = await fetch(`/api/transcriptions/${transcriptionId}/title`, {
                method: 'GET',
                headers: { 'Accept': 'application/json', 'X-CSRFToken': window.csrfToken }
            });

            if (!response.ok) {
                window.logger.error(pollLogPrefix, `Error fetching title status (${response.status}). Removing from poll.`);
                idsToPollForTitle.delete(transcriptionId);
                delete titlePollAttempts[transcriptionId];
                return;
            }

            const data = await response.json();
            const titleElement = document.getElementById(`title-${transcriptionId}`);
            const iconElement = document.getElementById(`title-icon-${transcriptionId}`);

            if (!titleElement || !iconElement) {
                window.logger.warn(pollLogPrefix, `Title or icon element not found for ID. Removing from poll.`);
                idsToPollForTitle.delete(transcriptionId);
                delete titlePollAttempts[transcriptionId];
                return;
            }

            switch (data.status) {
                case 'generated':
                    window.logger.info(pollLogPrefix, `Title generated: '${data.title}'`);
                    titleElement.innerHTML = `${window.escapeHtml(data.title)}<i class="material-icons tiny text-primary align-middle ml-1" id="title-icon-${transcriptionId}">auto_awesome</i>`;
                    titleElement.classList.add('title-updated'); 
                    idsToPollForTitle.delete(transcriptionId);
                    delete titlePollAttempts[transcriptionId];
                    break;
                case 'failed':
                case 'unknown':
                case 'disabled':
                    window.logger.warn(pollLogPrefix, `Title generation status is '${data.status}'. Using filename. Stopping poll.`);
                    titleElement.innerHTML = `${window.escapeHtml(data.title)}<i class="material-icons tiny text-primary align-middle ml-1 hidden" id="title-icon-${transcriptionId}">auto_awesome</i>`;
                    idsToPollForTitle.delete(transcriptionId);
                    delete titlePollAttempts[transcriptionId];
                    break;
                case 'processing':
                case 'pending':
                    titlePollAttempts[transcriptionId] = (titlePollAttempts[transcriptionId] || 0) + 1;
                    if (titlePollAttempts[transcriptionId] > MAX_TITLE_POLL_ATTEMPTS) {
                        window.logger.warn(pollLogPrefix, `Max poll attempts reached for title generation. Stopping poll.`);
                        iconElement.classList.add('hidden'); 
                        iconElement.style.display = 'none';
                        idsToPollForTitle.delete(transcriptionId);
                        delete titlePollAttempts[transcriptionId];
                    } else {
                        window.logger.debug(pollLogPrefix, `Title status is '${data.status}'. Continuing poll (Attempt ${titlePollAttempts[transcriptionId]}).`);
                    }
                    break;
                default:
                    window.logger.error(pollLogPrefix, `Unexpected title status received: ${data.status}. Stopping poll.`);
                    iconElement.classList.add('hidden'); 
                    iconElement.style.display = 'none';
                    idsToPollForTitle.delete(transcriptionId);
                    delete titlePollAttempts[transcriptionId];
            }

        } catch (error) {
            window.logger.error(pollLogPrefix, "Error during title status fetch:", error);
            const iconElement = document.getElementById(`title-icon-${transcriptionId}`);
            if(iconElement) { 
                iconElement.classList.add('hidden');
                iconElement.style.display = 'none';
            }
            idsToPollForTitle.delete(transcriptionId); 
            delete titlePollAttempts[transcriptionId];
        }
    }

    /**
     * Starts the interval timer for polling title statuses.
     */
    function startTitlePolling() {
        if (state.titlePollIntervalId) {
            window.logger.debug(historyLogPrefix, "Title polling interval already running.");
            return;
        }
        if (idsToPollForTitle.size === 0) {
            window.logger.debug(historyLogPrefix, "No transcription IDs to poll for titles.");
            return;
        }

        window.logger.info(historyLogPrefix, "Starting title polling interval...");
        state.titlePollIntervalId = setInterval(() => {
            if (idsToPollForTitle.size === 0) {
                window.logger.info(historyLogPrefix, "No more IDs to poll for titles. Stopping interval.");
                clearInterval(state.titlePollIntervalId);
                state.titlePollIntervalId = null;
                return;
            }
            const idsToCheck = new Set(idsToPollForTitle);
            window.logger.debug(historyLogPrefix, `Polling titles for ${idsToCheck.size} IDs...`);
            idsToCheck.forEach(id => fetchTitleStatus(id));
        }, TITLE_POLL_INTERVAL_MS);
    }
    window.startTitlePolling = startTitlePolling;

    History.polling = { fetchTitleStatus, startTitlePolling };
})(window);
